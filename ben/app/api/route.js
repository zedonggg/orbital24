import { NextResponse } from 'next/server';
import { PassThrough } from 'stream';
import multer from 'multer';
import Groq from 'groq-sdk';
import fs from 'fs-extra';
import path from 'path';
import os from 'os';
import { createClient } from '@/utils/supabase/client';

const groq = new Groq({ apiKey: process.env.NEXT_PUBLIC_GROQ_API_KEY })

export const maxDuration = 60;

const supabase = createClient();

function splitter(longtext, maxChunkLength = 3000) {
  const words = longtext.split(' ');
  const chunks = [];
  let cur = "";
  let counter = 0;

  for (const word of words) {
    if (counter >= maxChunkLength) {
      counter = 0;
      chunks.push(cur);
      cur = word;
    } else {
      cur += (cur ? ' ' : '') + word;
      counter += 1;
    }
  }

  if (cur) {
    chunks.push(cur);
  }

  return chunks;
}

async function summarizeChunk(chunk) {
  return groq.chat.completions.create({
    messages: [
      { role:'system', content: 'You are an AI assistant that summarizes text concisely for students while preserving important technical info and dates. Provide summaries directly without using labels or prefixes like "Summary:" or similar. Start your response with the actual content of the summary.'},
      { role: 'user', content: `Summarize the following text: \n\n${chunk}`}
    ],
    model: "llama3-8b-8192",
});
}

export async function POST(request) {
    try {
        const data = await request.json();

        console.log(data);

        // const { data, error } = await supabase.storage.from('audio_files').download(fileName);

        // if (error) throw error;

        const audiofile = await fetch(data.fileUrl);
    
        // if (!file) {
        //   return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
        // }
    
        // const buffer = await file.arrayBuffer();
        // const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'audio-'));
        // const filePath = path.join(tempDir, 'output.mp3');
        
        // await fs.promises.writeFile(filePath, Buffer.from(buffer));
    
        const transcription = await groq.audio.transcriptions.create({
          file: audiofile,
          model: "whisper-large-v3",
          response_format: "json",
          language: "en",
        });

        // console.log(transcription.text);
        const transcription2 = {
          text: "Okay, let's get started. Welcome back to CS2040S. Here we go, our second class of the semester. And today only, we have our one hour, one day only, learn everything you need to know about Java in one hour. Okay, I'm exaggerating a little bit. Hopefully you have some other, hopefully you're taking 20, 30, or you have some other experience in Java. But today, today our goal is to cover very, very quickly, we're going to race through the fundamentals of Java so that you'll be all set for problem set one and the rest of the class. So that is our goal for today. Okay. I'm just checking now if anyone in the chat is going to complain about echoes. Is audio okay today? We solved the problem? Okay, good. So today, let's start with some admin stuff. Yesterday we sent out tutorial and recitation announcements. Your time slot for these is fixed. The specific section you are in may change a little bit today as we do some balancing within a time slot. If we have a time slot with 20 people in one tutorial and 13 in the other. We're going to do some cross tutorial balancing. But the good news is we are basically able to get everyone a first choice tutorial slot, which we are excited by. We're able to keep the tutorials a reasonable size, which we're excited by. And we will, again, do finish the balancing today so you can get assigned to your tutor, get to know your tutor, and so on. Occasionally, I've had someone ask me, gee, do I have to attend the tutorial that I was assigned? The answer is yes. The tutorial, your tutor is your connection to this class, your guide through this class. You know, you really want to attend your tutorial, get to know your tutor. They're the ones who are going to be able to help you through this class. One warning I want to make. Please do not use mod reg to or course reg now, I suppose, to adjust or swap or otherwise appeal for or modify your tutorial or recitation. this all has to go through us if you change things directly on course reg it will only cause trouble we've gone to some effort to get this to balance well okay let's see some other stuff help i don't have a slot some of you have been saying well the thing to do then please fill out the appeal on course mology there is a new new survey we opened yesterday for if you don't have a slot, if the slot we assigned conflicts with another class that you have. Some of you, for example, we tried to input your selected slot in the system, and alas, CourseReg rejected it because you already have another class at the same time. You're not allowed to have overlapping classes. So if you have a conflict, if you don't have a slot at all, please fill out the appeal on CourseMology. The deadline is Thursday tomorrow at noon. When I say don't have a slot, by the way, I mean in terms of the announcement we made, not in terms of whatever Canvas says. Canvas doesn't seem to have updated yet with whatever has been propagated to the system. I gather that's going to update tomorrow when all the other announcements come out. Good. So yeah, help my slot conflicts. Again, please fill out the appeal on Chorismology. Deadline tomorrow. Some people help, I don't like my slot. If you don't like your slot, but there are no conflicts, than I'd ask, please try to find someone to swap with. There's a Coursemology forum where people have posted lots of swap requests. If you go there and look for a swap, hopefully you can find someone to swap with. We will happily entertain swaps this week. After this week, we're going to shut things down and be done. So if you want to swap, do it this afternoon. OK? Good. And again, just a reminder, please don't go and update things yourself on Course Reg or whatever. We have the master list of where everyone's assigned to. If you go change things yourself, we're going to revert it back, and it'll just be a headache for everyone. So please don't. The only way to do changes is via a Coursemology appeal. OK? Good. Other notes, please do check the Coursemology announcements. We'll keep you updated on the status, deadlines for these surveys, what's happening with these assignments, and so on. OK? As you may have noticed, problem set one is now available on Coursemology. It was as of Monday. The full description of the problem is in the PDF file with some frequently asked questions at the end. It's due sort of Sunday night, Monday morning. If you're, well, first of all, hopefully we'll address some of people's questions today. Our one hour review of Java will hopefully cover some of the things that people have been finding confusing. On the other hand, if you are still confused, running into problems and so on, please do check the discussion forum on Coursemology. there's been lots of discussion of how you get the jdk set up properly i can't speak today sorry how do you get that set up properly how do you get java to run properly how do you integrate it properly into intelliJ lots of discussion lots of attempts to solve people's problems go at go check if your problem is already solved and if not ask questions there yeah other questions why is my image blank why is my image wrong cultural reference issues of i don't recognize the person in that picture, even though I've decoded it properly. All good. These are all fair and valid questions to ask. In general, we're going to ask that you don't, for example, post the entire code of your solution on the forum. People are supposed to solve the problems themselves. Posting the code so other people can help you debug is not allowed, but lots of other questions are. Okay, good. Fine. Ah, one other warning. Beware, there is a button on the problem set and lecture review that says finalize submission. In case this is confusing, what that means is it finalizes your submission. If you click the finalize submission button, your submission is finalized. You cannot change it anymore. Okay, so please try to only click the finalize submission button when you are actually done with the entire problem set or the entire lecture review or the entire contest or whatever the entire thing is that you're trying to submit. This is the first week. I know we're all sort of learning the ropes. We're learning how the system works, learning what the different buttons mean. So this week we are being very flexible and handling lots of accidental unsubmissions. But going forward in the future, we will be less happy about that. So figure it out this week. Next week should all be good, right? Good. One other question that comes up a lot on problem sets. What Java libraries can I use? In general, the philosophy we want, the underlying principle here, is that you shouldn't be using libraries that overly simplify the problem. If the problem is, please write a sorting routine, and you're like, aha, I can do that. I'll just call the Java library sort. You've kind of defeated the purpose of the problem now, haven't you? So if using a library is going to basically make the problem trivial, you probably shouldn't be using it. Otherwise it might be okay. This week again, we're being very flexible. This first problem set is just a warm-up, so we all get our systems working. But in the future, for future weeks in general, you should only use libraries that the problem set specifies that you can use. We will try to be clear on the problem set. These are libraries that are okay. ArrayList is fine this week, then you can use it. Otherwise, don't be using libraries we're not talking about. Good. Archipelago, it's up and running again with a few questions open right now. Feel free to go and answer questions. A nice little distraction from listening to me or staring at a screen all class. That's fine. I always have a random question survey open. So if anything comes up, you can ask. Sometimes I can answer them directly during class. Otherwise, I will try to answer interesting questions on the forum after class is over. Alas, it's hard for me to talk to you all here, watch what's happening on Zoom and monitor all the Archipelago questions. So I'll try to answer them after class. Starting next week, there'll be a small amount of EXP available for interacting with Archipelago. If you join the class late, you might not properly be in the system. Sorry, we'll get that fixed. Otherwise, you should have got an email from Archipelago. You should get one before every class. Check your spam folder if you are not finding it. Okay. Good. And just for the fun of it, let's see. What I was asking today is questions like, how much experience do people have with Java? Because some people think that everyone in this class is a Java expert except them. and what you'll notice from the survey, and I can post this later, is that you'll see that some people do have a bit of Java experience. There are a bunch of people over here saying, gee, I've written some small programs, a few people that feel fairly comfortable with it, and a lot of people over on the left here that have never used Java before or basically have written hello CS2040S and that is it. So wherever you are in this chart, you are probably in good company. And this is part of what I like about Archipelago. We can get some sense for, you know, we can get some shared sense of what is going on. You can see here for who's taking 2030S. The large majority of you are taking 2030S this semester. What else do I have? What other questions do I have here? Ah, have used a debugger. We'll talk about debuggers in a little bit. yeah, what is the biggest program you've worked on? Another sort of interesting questions. And again, the large, large majority of people in the class have never worked on a program bigger than 200 lines of code, which makes a lot of sense to your first year CS students. And then of course, there's always the, you know, a couple of random people in the class who've actually worked on some larger programs. Okay, good. As I said, I'll post some of these results after class just for the fun of it. Okay, good. So, all that said, we can now get on to our one-hour review of Java. Less than an hour now. Okay, 40 minutes. Basics of object-oriented programming in Java. Let's go. So the first warning I'll give you is that today we're going to be talking primarily about the basics of object-oriented programming in Java. For more advanced topics, certainly go see 2030S, go see Google, look at this textbook. Today we're focused on just the basics, which I think is what you need for this class. So Java has all sorts of quote-unquote advanced features, things like lambda expressions and so on, and does things like type inference, and has all sorts of things it does. But here's my advice to you, especially you who are newer to Java programming. I would not start out using these advanced features. The main goal of a lot of these features is to make your code shorter. They add generally very little functionality. They're mainly about compressing your code, letting you write fewer characters, and they often hide what's really happening. That can make the code easier to read because it's shorter or can make code harder to read because you've hidden stuff in sort of default and more complicated behaviors. Okay? So especially if you're new to Java, I'd focus on just using the standard features of Java. I mean, really, in general, when you're writing code, what are your goals? Like I said last on Monday, it's always good to think about what you're trying to get out of something. You should try to write code that's correct and bug-free. Good. You should make the code easy to read and understand. Yes. Efficient, certainly. In this class, you want to submit by the deadline. Good. And you can go on and on and generate this list. Having your code be short, I'd suggest, is probably way down the list of importance. OK? Good. So second piece of advice is make your code intentional. There's all sorts of default behaviors built into Java in any programming language. My advice is don't rely on sort of default and non-explicit behavior. Again, especially if you're new to Java, try to be intentional about your programming. make sure you are expressing exactly what you want your program to do. Good Here some more advice Use a debugger So on the question where was it On the Archipelago question I was asking people have you used a debugger before Here was that. And again, the large majority of people haven't really used a debugger before. I add lots of print statements to debug, option one, lots of people choose that. I would suggest that it's a great idea to learn how to use a debugger, especially as your programs get more complicated. Just adding a parcel of print statements everywhere becomes a huge mess. Debuggers are a wonderful tool for figuring out what's going on in your program. This is one of the reasons I recommend using IntelliJ is it has a nice debugger, an easy way to figure out what is going on. Click debug. Up here on the top right of IntelliJ, there's a little bug button. Click that. You can set breakpoints to stop your program when it gets to a certain point. Learn how to use this, your life will be a lot easier. Okay. Good. And you can step through your code and see what the variables are at any given point, right? You can see at this point in my code, my variables look like this, etc. Okay. Good. So, again, today's goal, we're just going to rapidly say a lot of things to make you aware of some key aspects of Java. After class, you can go look things up I've talked about and hopefully figure it all out. Okay. Basics of object-oriented programming. Good. As you've probably already heard, there are many different ways you can think about programming languages, many different programming paradigms. Procedural, functional, declarative, and so on, all deal with how do you want to organize the information? How do you want to think about a solution to your problem? In this class, we're talking about object-oriented programming and Java. There are lots and lots of different object-oriented languages out there, Java, C++, whatever. They're near ubiquitous in industry. And in general, the object-oriented paradigm has really taken over the way people think about programming pretty much everywhere. I would suggest that there are four underlying principles to object-oriented programming, four main components of it. Abstraction, encapsulation, inheritance, and polymorphism. The idea of abstraction. We want to separate the interface, what something is supposed to do, from the implementation, how it does it. Encapsulation. We want to hide the implementation, only make the interface publicly visible. I'm going to talk more about both of these as we go on today. Inheritance. Build new classes by extending existing functionality, sharing functionality among pieces of your code. And polymorphism. Things have the same interface but behave differently based on context. I am not going to talk much about inheritance or polymorphism. Go take CS2030S for that. So abstraction and encapsulation, these are going to be very important as we work through our different algorithms and data structures. Inheritance and polymorphism are very important in general, but we're not going to think a lot about today or this semester. Again, go take 2030S, and you'll hear a lot more about those topics. Okay, so what is this whole abstraction thing? Here's everyone's favorite example. imagine that we've just hired Naruto, this friendly gorilla here. Nice guy, likes bananas. Not the smartest fella, but he's friendly. But I'm afraid he's going to mess up the code. Who knows what he's going to do? So what can we do? We could give him some pointless work, send him back to the forest, but we'd like some help with this project, and we don't want him to wreck our software. So we run into the idea of abstraction. We want to remove all the unnecessary elements. Whatever Naruto needs to know, we want to expose. And what he doesn't need to know, we want to hide. Keep things as simple as possible for our little friend over here. Good. So this is the basic idea of encapsulation information hiding. We have an implementer over here who builds this private data and private methods and so on. And then we have a public interface over here, which Naruto is going to interact with, which all the users are going to interact with, the users of our code. Great. And here's the basic claim. This is actually all of us. We are all about as smart as this gorilla here when it comes to programming. Why is that? Not because we're stupid people, but because software is getting incredibly complex. It used to be that you might say, oh, a million lines of code. Yeah, most code isn't too big. I can learn a million lines of code. But alas, a million lines of code is no longer a particularly big program. Lots of programs you deal with today are in the tens and hundreds of millions of lines of code. Car software is my favorite example from this graph. Why is car software 100 million lines of code? I don't know. Didn't realize car software was that complicated. Anyways, and if you ever get a job at Google after you graduate here, there is absolutely no way you're going to be able to keep track of everything that's happening in the Google code base. Even Jeff Dean probably can't keep track of everything happening at Google code base. So yeah, this was from a few years ago. This was from 2016, so it's out of date. It's probably twice as big today. But in 2016, they announced they had something like 35 million commits during the Google lifetime with 2 billion lines of code. So completely impossible to wrap your mind around numbers. So code is super complicated. Programs are super complicated. If you have to understand everything to write new code, you'll never be able to contribute. You'll never be able to add to the data to the Google code base if you have to understand 2 billion lines of code first. So the solution, again, is this idea of abstraction and encapsulation. We're going to hide a lot of the things we don't need to know and only expose the interfaces the way we interact with them. Good. This idea is incredibly useful for software engineering. You'll take 2103 next year is my guess. And you're gonna talk all about this idea of abstraction, this idea of dividing your problem into components, defining interfaces between your components, and then you can assign a team to build each component and recurse, okay? This is sort of the top-down design idea. Get a big idea first, and then figure out how to implement it. Good. It turns out this goes beyond software engineering. You know, I am mostly an algorithmicist, an algorithm designer or a theorist. It also shows up in algorithm design. Even in algorithm design, you want to divide your problem into components, figure out how they interact so you can solve each problem separately. So whether you're a theorist or a practitioner, this basic paradigm still holds. So we're talking about object-oriented programming. What is an object? An object is something that has state and behavior. State has some data, something you've stored in it. behavior some way for modifying the state. Here's everyone's favorite trivial example. Imagine we have a classroom. Hey, a classroom, we're in one. What does a classroom have? What is the relevant state for our classroom? Well, we have a list of students. We have a number of chairs. Maybe there's the room temperature. I don't know. We have some data about our classroom that's stored inside our classroom object. We also have some ways of interacting with our classroom object. You can enter the classroom. You can leave the classroom. or I can ask for a count of the number of students in the classroom. Right? Good. So this is sort of one example of an object. Here, given that, let me ask a question. Go to Archipelago and tell me as soon as I open the question. What do you think a good design for a file system object structure would be? I've given you four options here to think about. file management and file contents objects, file objects, folder hierarchies and folder contents, or file objects and folder objects. So run over to Archipelago and tell me what you think, what would be the best way to design your object-oriented file system. I'll give everyone a minute or so to go to Archipelago and choose an answer. Okay, 10 more seconds. Get your guesses in. Okay, let's think about this a little bit. Let's think about our first option. I don't think, so first, the first thing I should say, by the way, is that some of these issues are design decisions, and you can make your favorite argument for your favorite option. But let me give you the standard answer here. I don't think file management objects and file contents objects are right, in the sense that, in general, you want an object to represent state. You want to represent the thing that's being captured, you don't tend to want it to be a verb. The actions and verbs are the ways you interact with it. The object itself generally sounds like a noun, a thing. So we don't really want to have this separate notion of an object that manages files. That's sort of an activity you do to something. You want that to be part of the object itself. The behavior is part of the object, not a separate object. So objects represent state. You shouldn't be having verbs like file management in them. Sort of verbs. Anyways, so what about the file object? No, not super happy with that. What about folders? It doesn't seem to capture everything that we want about our file system. How about a folder hierarchy and folder contents? Again, we'd like to have a more unitary concept here without having to divide the functionality between two things. I'm sure you can make this work, but in general, we want to have a single thing if we can, or a single sort of unified way of looking at the world. And so in general, I would argue that a file object and a folder object gives you the best sort of standard object-oriented way of thinking about this. These are nouns. We have files and folders. These are our base objects. They fit well together. Maybe they're even the same type of thing, files and folders. You can ponder that. And you can imagine having ways to work with them. So for example, what are our files and folders going to look like? Our files are going to contain data. Good. They also have some way to modify them or update them. You can edit them, rename them, and move them. How about our folder? Our folder, again, contains some stuff. This is the state that's contained in it. It contains some files. It contains some folders. And again, it has some ways that you can interact with it. You can rename it and move it. So we're thinking about our objects in terms of the state. What do they contain? And the behavior, how do I interact with this thing? Okay? Okay? So, on to Java, then. How are we going to do this in Java? The very first principle of Java, the first thing that you have to know about Java is everything is an object. Okay? Everything, everything you look at in Java is an object. Even if you don't think it is, it is an object. Okay? You know, some people say, wait, I was told that Java is now a functional language. What about lambda expressions? What about anonymous functions? To Java, these are just disguised objects. Everything in Java is under the covers an object. If you understand that, it will behave the way you expect. If you don't, it's going to behave weirdly. Good. So what is a class? A class is just a template for producing an object. That's all it is. It's just a set of instructions for how to make an object. This is what your object should look like. OK, great. So here is an example of defining a class in Java. Here is our file class. Please don't be confused by the dot, dot, dot on my slides. This is not Java syntax. This is me not able to fit long bits of text on my slide. I'm using this as non-Java ways to replace stuff I'm leaving out. OK, good. So how do we declare our class in Java? Well, class file. Good. We have a file class. Classes tend to start with capital letters. Note that the name of your class must be the name of the file. This is one of these weird Java rules. If you want a class file, you put it in the file file.java. Great. Good. You initialize variables when they're first defined. There is default behavior. If I don define the variable it will just get some default empty value My continued advice to you is don rely on default values Be explicit If you want a null contents for your file declare it null If you want an empty string, call it an empty string. Your life will be easier. Debugging will be easier if you express your defaults. Next year, as you get better at Java, you may rely on defaults more. For now, this will make your life easier. Good. Second principle of Java. The second most important thing you know about Java is everything has a type. This might be surprising if you're coming from Python or JavaScript or other languages. But in Java, everything has a type, a fixed type, a type that does not change. Okay? So, you might say, ah, but I heard that Java has this thing called bar, just like JavaScript, where I can leave an unspecified type. To Java, this is not an unspecified type. It just means it's going to try to guess the type for you. There still is an underlying type, even if it's trying to guess it for you. So examples, I declare my j to be an integer. I then try to assign it the string value of 7. This is an error. Can't do this. I declared it an integer. It has the type integer. It will not change. It will now be an integer forever. And if I try to assign it something not an integer, poof. Just because I use var, which again, you don't need to worry about in general, but just because you do that doesn't change that fact. At this point, Java has already decided, it's guessed that j is an integer. integer, it's going to be an integer forever. Everything has a type. And again, my advice is to always specify the type. Don't rely on type inference. If you specify the type explicitly, it will be more clear to you what you are doing. Good. So here back to our file, our class file, we have some examples of some types. We have a string type. Notice one of our types here, file data, that's another class. So another class is a type. File data is not something built into Java. That's just another object type. We have a void type. That's an empty type, and so on. So what about these strings? So string is actually not a entirely built-in type in some ways. It's actually a separate Java library, one that you can use, by the way, always. But it's actually, you can go look up the source code for the string library, the string class in Java. And what you'll find, and anyways, this is how strings work roughly. You can create strings. Strings are special in that you can create them just by assigning a string to them. That's nice. Strings have a bunch of functionality that you can look up. In general, this docs.oracle.com has lots of documentation on all the Java functionality. I'm just listing a small number of things here to encourage you to go look up all the functionality that strings have that you might find useful. Great. One sort of point I'll make, one of the pieces of functionality strings have is it lets you compare them to each other. Compare to will compare two strings, equals checks if two strings are equal, and so on. We already saw on Monday that you can just add a character to a string. How easy is that? It's wonderful, except, as we also saw on Monday, it can lead to horrendous performance. So be careful when you are just using the functionality. functionality. It's one thing to remember. There's lots of underlying functionality, but it has a cost to it. And the cost may not be evident unless you go look at the documentation, which will explain it. So be careful that some things are more expensive than they seem. I will comment on this equals thing, just because this is a common sort of beginner error in Java, is people say, oh, why do I need this equals thing? I can just compare my two strings by saying, oh, you know, if my name equals equals prof name, then do something. It turns out that if you do this in Java, it will not always give you the right answer. Sometimes you'll get lucky and it will, sometimes it won't. What equals equals is checking here is, are these strings stored in the same place in memory? It's not comparing the contents. It's not doing a character by character contents comparison. It's checking, are they stored in the same place? Sometimes the compiler is clever and says, oh, these are the same strings, so I'm only going to store it once in memory, and then this works. Sometimes that's not the case and then this fails. So be careful comparing strings. Try to use the built-in functionality which will do the right thing. Good. So back to our Java class. Good. Okay, back to our Java class. Here we go. So a Java class contains, remember objects contain data and behavior, state and behavior. The state of your class is contained in the member variables, often called the instance variables, if you're reading object oriented literature. The instance variables are just the variables contained within your object or defined by your class. In this case, we have two of them. We have a name and we have some contents. This is the state of your object. An object also has some ways to modify it. Right? This is the behavior. This is how you interact with it. Here we have three types of behavior. You can rename it. You can get the data. You can set the data. This is obviously a silly example, but hopefully it illustrates the basics of what an object looks like. Good. So now we know how to define a class in Java. Here's another example of a class. Here's a folder class. I think the reason I have this example is simply to highlight that you can actually have recursive definitions of classes, as in this folder class contains within it an array of folders. Fine, good. That works happily. And of course, notice the notation for arrays. Good. So here is everyone's favorite question. What is the difference between a class and an object? It's important to keep this in mind. I'm actually not going to pause very long here for this because we only have limited time left in class. but make sure you understand the difference between a class and an object. Notably, the class is a template for how to make an object. The object is an instance of the class. Keeping this difference in mind will clarify a lot of issues. For example, static variables and so on. We'll get to in a sec. We'll all make more sense if you keep in mind the difference between the objects, which are instances, and the class, which is the template for how to build an object. Good. So how do you make a new object? Well, new is the keyword that you need for that. This creates a new folder object and stores it in the red folder variable. One thing notice here is you'll notice that we have a variable, we have an input parameter to create this new class. What is that and where does that go? This goes to the, so this calls the constructor, the thing that is going to build the class with the parameter name. So we haven't talked about constructors. What is a constructor? A constructor is a special function that you include in your class. Here is an example for file. Notice it has no return parameter. And it has the same name as the class itself. This is class file. The constructor's name is file. It takes one parameter, in this case, file name. It could also take zero parameters. That's fine. And it usually, a constructor is used to initialize your object. Good. These are constructors. You can have more than one of them. They run after the variables are initialized on declaration. So after this is set to empty and null, but before anything else happens. In general, there are all sorts of rules involving constructors, and especially the order in which they're executed if you have more than one constructor, and especially if you have inheritance that becomes complicated. I'm not going to get into this today. If you just have one simple constructor, you won't have a problem. If you have a more complicated class that's inheriting from some complicated hierarchy of classes, then you need to make sure you understand this question of what order constructors are executed in. Good. So we've talked about abstraction, and we've begun to talk about encapsulation. Let me say a little bit more about encapsulation here. So we have this idea that an object has state and behavior. And we have our example of a classroom here. And the point is that we don't actually care what's happening inside the classroom a lot of the time. We are here on the outside. We want to use this object. We'd like to interact with it. But I don't really care how you've implemented it. You can implement it however you like. Doesn't matter to me as long as students can enter the class and leave the class and I can get how many people are here. All good. I don't care what you've done. This is encapsulation. This is the point of data hiding. In Java, how do you do this? The key thing you need to know in Java about this is Java uses interfaces to accomplish this. So a Java interface specifies how you interact with something. It has no bearing on what it actually does. So for example, here is my file interface. It lets me rename my file, lets me get data from it and set data. Hey, there's no implementation. This is actually intentional. Note the semicolons at the end here. There is no implementation. This just specifies what type of behavior expect to be able to do. It doesn't actually do anything. Good. If you come from a C++ world, this is not the same, by the way, as header files in C++. This is entirely different. This is specifying how you interact with something. And you can have lots of different classes that implement this interface. Good. Oh, and you'll notice, by the way, as we go through, I'm encouraging you to make sure to add comments to your code, say explaining what your interface is for, how you should use your interface, et cetera. Since the interface is the public-facing view of your work, it's a great way to explain how do you use this code that I've built. OK? Good. So what do you do with an interface? There's no implementation in it. So what an interface does is you use it. You promise to implement it. You're building a class file. And you're saying, great, this class implements this I file interface. By the way, I'm using this capital I here just to be typographically clear what is an interface. That's not a standard Java naming convention, but I find it helps for today so that we know what are interfaces and what aren't. So good. Here we have our ifile interface. If I write this piece of code, if I write implements ifile, I have to implement all the parts of this interface. That's the promise I am making to you, is that all of these parts are implemented. More than one class, of course, can implement the same interface. That's the whole idea here. Here's another file. This is a French version of the file, it seems. And it also implements the iFile interface. And from your perspective, if you want to use a file, you don't care which implementation you're getting. You're just going to use it as the interface, via the the interface. Okay. Oh, this is an example. We don't have time. Let's not do Archipelago now. But if you think about this, you'll notice for a sec, this is not correct code. This will fail when you try to compile it. Why is this going to fail? I didn't implement the third part of the interface. The interface promised three things, rename, get data, and set data. And of course, I am missing here the rename functionality. So this will fail. You must implement all parts of your interface. OK? Great. Here's an example of how to use an interface. OK? So I want to use this interface without knowing anything about what is in my object, what the object is doing. I have written here some code for copying a file that doesn't, I don't care what type of file you have. If it implements ifile, I can pass it in as a variable. As long as it implements the interface, I can pass it as a variable to copy file. Good. But once I've done that, I can access it. I can use it via the interface. The interface has get data, so I can call get data on it. Great. I can build a new file. Notice my new file is a specific type of file. This is my file type. I can set the data, and I can return it. Notice the only thing I promised is that I'm going to return something with the type ifile. That's great. I am. My file is also an ifile. I can happily return that, and everything is good. and whoever is using my copy file code doesn't care what type of file I was using. As long as it satisfies the interface, they're also happy. All the interaction with the object is via the interface. Good. And we're already seeing this on problem set one. The way we specified what you should do on problem set one was we give you an interface and say, please implement this. Okay So so far basics of object programming In the remaining 10 minutes I going to zip through a few more things that you might want to look into later First of them access control Basic idea in Java, behavior should be public, data should be private. Good. So this is back to the idea of encapsulation, by the way. I don't care what's in your object. Wow. I don't care what's in your object. All I care is how you interact with it. Good. So here's an example. My data here is private. We have these keywords, public, private, protected, and so on. First of all, my class is public. Everyone can use this class. The internal variables are private. So I don't want anyone else messing with the state of my object. Some of the functionality, rename get data, set data, this is public. Anyone can use this. Some of my functionality, compressed data storage, This is private. Why is compressed data storage private? Because this is internal to my object. This is about how I'm implementing the object. It's not how I expect the world to interact with my object. So access control in Java, none specified means everyone in the same package can use the thing, public, everyone, private, only in the same class, and protected within the same package and subclasses. We're not going to worry so much about this because we're not talking about inheritance. The thing that will matter most to you is public and private. Again, my strong advice is to declare whether your variables are public or private. Be explicit. Don't depend on default behavior. So here are some examples of access control. I have a public class up here. I have another public class here that has a method, stealSecrets. stealSecrets takes this thing example, and it tries to call the secret function. Aha, it cannot call the secret function because the secret function is private. We can't call a private method on another class. Good. If it were public, we would be able to. So if we make this public now, we can access it. If we make it private, we don't. But in general, you don't want to make your internal state public. Generally a bad idea, not recommended. OK? Good. A constructor. Your constructor should almost always be public. Why is that? If your constructor isn't public, no one can build your object. That's a bad idea. If you're making an object for people to use, you almost always want the constructor to be public, so other code can actually build your object. Interfaces. Interfaces are almost always public. Why? An interface is how you interact with the object. I'm going to interact with this object, that needs to be public. If your interface contains private methods, then no one can use your interface, again, that seems like a bad idea. Good. So access control, public, private, and so on. Recommendation, declare your variables and functions to be public or private. Good. Again, always specify what you intend to be intentional about your code. Packages, we just mentioned, packages are a way of grouping code together. We're not going to worry about packages on our problem sets, but you should know they exist and look them up if you care. One nice thing about packages is it lets you import a whole bunch of code at once. Imagine you have a CleverCode package. You can import CleverCode.star and get everything from it. Import in general is used to import libraries and packages and functions and so on, and classes and so on. Good. So for example, if you just want to import the shift register from CleverCode, you only need to do that. You don't need to import the whole package. you can just import this one class that you happen to want. And now everything is happy. OK. Other examples, yes. So for example, one class that we'll run into at some point is a HashMap. This would import the Java util HashMap. As I said, on problem sets, see instructions for what you can use. OK? Good. OK. One more piece of Java trivia, useful feature of Java. Remember, classes versus object. A class is a template for how to make an object. An object is an instance of that. So most of your variables and functions are per object, one copy of each variable per object. If I create many copies of this object, I get many copies of the variable. Static variables are different. Static variables are shared across all the objects in the class. So a static variable is, in some sense, global across the entire class. There's only one copy of it for all the objects in that class. So regular variables per object, static variables per class. This causes some confusion. So for example, if I have a static function here, add extension. So far, this is fine. It takes an input name and adds PDF to it. That's great. There's only one copy of this for the entire class. And my laptop is just turned off. Lovely. Lovely. Sorry, we're going to need one second to figure out what happened. Only five minutes left in class so this is almost good timing if it had given me five minutes more. What is going on. Do, do, do, do, do. Technical difficulties in both the first two classes. That's a real record here. Thank you. Thank you. Thank you. Thank you. Thank you. Okay. Sorry about that. Unexpected break. Three minutes left in class. So, oh, well. What I was trying to get across in these three minutes left was what static means. Again, Static is per class. Regular variables are per object. Good. So what was the point? I was giving some examples as to how this works. So if we have a static thing within our class, that's fine and well and good. We can add the string back to the end of it. But here, for example, you will discover there is an error. Why is this an error? What went wrong here? Well, what went wrong here was that file name is not a static variable. File name is per object. But this function here, addExtension, is per class. Which object should this be adding the file name to? Who knows? It's not specified. So this is an error. Java has no idea what to do with this. Yeah. The screen isn't on. How did that happen? Wasn't it on a second ago? No. Oh my god, this is amazing. Why is the display turn itself off. I am super sorry. Um, what is going on. Okay. We have a screen now. You can hear me. I'm not echoing too much. Oh, my God. My apologies. We don't usually use this room. Usually we're over in SOC. Anyways, I was trying to explain what happens wrong with static. We're going to be out of time. So I will, I guess, leave the slides for you to look at these examples. And hopefully this will make some sense. If not, we can talk about this on the forum. But the point about static is to keep track of whether you are updating a class or whether you are updating a object. And we have some examples here. This is an example of a static variable where things are OK. OK, good. I just had a few more examples here, but this is roughly what I wanted to get to. There are all sorts of Java operators you can look up. You should go look these up. These will be useful to you. Things like shifts and testing equality and logical and and or, all useful. These are Java's primitive data types. Again, look it up. They'll be useful to know. Yeah, that was, I guess, what I wanted to get to. I also list on these slides, which again, I'll post right after class, some common problems that people have been having, things like library setup questions. Your file isn't running properly. Do you have a main method and so on? The file isn't compiling. Check all the red squiggles. The image file comes up empty. Make sure the file's in the right place. Other problems, see discussions on the forum. And Google any weird error messages you have. One thing I'll say, I've said a bunch of times, is you're going to have to look some of this stuff up yourself after class. Oracle has some great documentation on Java basics and object-oriented programming, both recommended. And that's it. From Puzzle of the Week last week, by the way, these were non-transitive dice. There are some more examples of dice puzzles if you're interested, the Sickerman dice. And next week, we'll talk about search and hopefully have fewer technical difficulties. Sorry about that again. Have a good rest of your week, and I'll see you on Monday. Thank you."
        }
        // const allchunks = splitter(transcription.text);
        // console.log(allchunks.length);
        // const summaries = []
        // for (const c of allchunks) {
        //   const chatCompletion = await summarizeChunk(c);
        //   summaries.push(chatCompletion.choices[0]?.message?.content || "");
        // }
        // const combine = summaries.join('\n\n');

        await supabase.storage.from('audio_files').remove([data.fileName]);
    

        return NextResponse.json({ transcription: transcription.text }, { status: 200 });
      } catch (error) {
        console.error('Error in transcription:', error);
        await supabase.storage.from('audio_files').remove([data.fileName]);
        return NextResponse.json({ error: 'Error in transcription' }, { status: 500 });
      }
}